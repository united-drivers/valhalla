// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: segment.proto

/*
Package segment is a generated protocol buffer package.

It is generated from these files:
	segment.proto

It has these top-level messages:
	Segment
*/
package segment

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// road classes are based on OpenStreetMap usage of the "highway" tag.
// each value of the enumeration corresponds to one value of the tag,
// except for ClassServiceOther, which is used for service and other roads.
type Segment_RoadClass int32

const (
	Segment_ClassMotorway     Segment_RoadClass = 0
	Segment_ClassTrunk        Segment_RoadClass = 1
	Segment_ClassPrimary      Segment_RoadClass = 2
	Segment_ClassSecondary    Segment_RoadClass = 3
	Segment_ClassTertiary     Segment_RoadClass = 4
	Segment_ClassUnclassified Segment_RoadClass = 5
	Segment_ClassResidential  Segment_RoadClass = 6
	Segment_ClassServiceOther Segment_RoadClass = 7
)

var Segment_RoadClass_name = map[int32]string{
	0: "ClassMotorway",
	1: "ClassTrunk",
	2: "ClassPrimary",
	3: "ClassSecondary",
	4: "ClassTertiary",
	5: "ClassUnclassified",
	6: "ClassResidential",
	7: "ClassServiceOther",
}
var Segment_RoadClass_value = map[string]int32{
	"ClassMotorway":     0,
	"ClassTrunk":        1,
	"ClassPrimary":      2,
	"ClassSecondary":    3,
	"ClassTertiary":     4,
	"ClassUnclassified": 5,
	"ClassResidential":  6,
	"ClassServiceOther": 7,
}

func (x Segment_RoadClass) Enum() *Segment_RoadClass {
	p := new(Segment_RoadClass)
	*p = x
	return p
}
func (x Segment_RoadClass) String() string {
	return proto.EnumName(Segment_RoadClass_name, int32(x))
}
func (x *Segment_RoadClass) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Segment_RoadClass_value, data, "Segment_RoadClass")
	if err != nil {
		return err
	}
	*x = Segment_RoadClass(value)
	return nil
}
func (Segment_RoadClass) EnumDescriptor() ([]byte, []int) { return fileDescriptorSegment, []int{0, 0} }

// form of way describes the physical attributes of the road.
type Segment_FormOfWay int32

const (
	// use FowUndefined if you do not know what physical attributes the road
	// has.
	Segment_FowUndefined Segment_FormOfWay = 0
	// use FowMotorway for motorways.
	Segment_FowMotorway Segment_FormOfWay = 1
	// use FowMultipleCarriageway for multiple carriageway roads. that is, when
	// there are separate OSM ways for each direction of travel.
	Segment_FowMultipleCarriageway Segment_FormOfWay = 2
	// use FowSingleCarriageway for other roads.
	Segment_FowSingleCarriageway Segment_FormOfWay = 3
	// use FowRoundabout for roundabouts
	Segment_FowRoundabout Segment_FormOfWay = 4
	// use FowTrafficSquare for roads which enclose an area, but which are not
	// roundabouts
	Segment_FowTrafficSquare Segment_FormOfWay = 5
	// use FowSlipRoad for slip roads, ramps and other links.
	Segment_FowSlipRoad Segment_FormOfWay = 6
	// use FowOther for roads which do not match any of the above definitions,
	// but for which the form of way is known.
	Segment_FowOther Segment_FormOfWay = 7
)

var Segment_FormOfWay_name = map[int32]string{
	0: "FowUndefined",
	1: "FowMotorway",
	2: "FowMultipleCarriageway",
	3: "FowSingleCarriageway",
	4: "FowRoundabout",
	5: "FowTrafficSquare",
	6: "FowSlipRoad",
	7: "FowOther",
}
var Segment_FormOfWay_value = map[string]int32{
	"FowUndefined":           0,
	"FowMotorway":            1,
	"FowMultipleCarriageway": 2,
	"FowSingleCarriageway":   3,
	"FowRoundabout":          4,
	"FowTrafficSquare":       5,
	"FowSlipRoad":            6,
	"FowOther":               7,
}

func (x Segment_FormOfWay) Enum() *Segment_FormOfWay {
	p := new(Segment_FormOfWay)
	*p = x
	return p
}
func (x Segment_FormOfWay) String() string {
	return proto.EnumName(Segment_FormOfWay_name, int32(x))
}
func (x *Segment_FormOfWay) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Segment_FormOfWay_value, data, "Segment_FormOfWay")
	if err != nil {
		return err
	}
	*x = Segment_FormOfWay(value)
	return nil
}
func (Segment_FormOfWay) EnumDescriptor() ([]byte, []int) { return fileDescriptorSegment, []int{0, 1} }

type Segment struct {
	// a segment is a list of at least two LocationReferences.
	//
	// all but the last LocationReference must contain a full set of data for
	// each field, but the final one should consist of only a reference
	// coordinate. any other information on the final LocationReference may be
	// ignored.
	//
	// a segment with only a single LocationReference is invalid and may be
	// ignored.
	Lrps             []*Segment_LocationReference `protobuf:"bytes,1,rep,name=lrps" json:"lrps,omitempty"`
	XXX_unrecognized []byte                       `json:"-"`
}

func (m *Segment) Reset()                    { *m = Segment{} }
func (m *Segment) String() string            { return proto.CompactTextString(m) }
func (*Segment) ProtoMessage()               {}
func (*Segment) Descriptor() ([]byte, []int) { return fileDescriptorSegment, []int{0} }

func (m *Segment) GetLrps() []*Segment_LocationReference {
	if m != nil {
		return m.Lrps
	}
	return nil
}

type Segment_LatLng struct {
	// lat & lng in EPSG:4326 multiplied by 10^7 and rounded to the nearest
	// integer. this gives a precision of about 1.1cm (7/16ths of an inch)
	// worst case at the equator.
	Lat              *int32 `protobuf:"fixed32,1,opt,name=lat" json:"lat,omitempty"`
	Lng              *int32 `protobuf:"fixed32,2,opt,name=lng" json:"lng,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Segment_LatLng) Reset()                    { *m = Segment_LatLng{} }
func (m *Segment_LatLng) String() string            { return proto.CompactTextString(m) }
func (*Segment_LatLng) ProtoMessage()               {}
func (*Segment_LatLng) Descriptor() ([]byte, []int) { return fileDescriptorSegment, []int{0, 0} }

func (m *Segment_LatLng) GetLat() int32 {
	if m != nil && m.Lat != nil {
		return *m.Lat
	}
	return 0
}

func (m *Segment_LatLng) GetLng() int32 {
	if m != nil && m.Lng != nil {
		return *m.Lng
	}
	return 0
}

// a segment consists of multiple LocationReferences, each of which describes
// the road at a particular reference coordinate, or properties of the road
// between the current LocationReference and the next.
//
// the first and last LocationReference reference coordinates will usually be at
// "true" intersections, which are intersections where there are multiple
// paths through the intersection. This excludes "false" intersections where
// two roads cross, but there are not multiple paths, such as overpasses,
// bridges, changes of road name or properties.
//
//          ___
//  |      /   \        _4---5--
// -1-----2     \    __/     |
//  |            3__/        |
//
// in the example above, the Segment consists of 5 LocationReferences,
// numbered 1-5. locations 1 & 5 are at true intersections with other roads
// and 2, 3 & 4 are intermediate LocationReferences inserted due to the length
// of the road.
//
// Occasionally, a LocationReference can be inserted along a road (i.e., not at
// a true intersection) to break long road segments into multiple OSMLR
// segments.
//
type Segment_LocationReference struct {
	// the reference coordinate.
	Coord *Segment_LatLng `protobuf:"bytes,1,opt,name=coord" json:"coord,omitempty"`
	// bearing in degrees clockwise from true north between 0 and 359 - will
	// generally fit in a couple of bytes varint.
	//
	// the bearing should be calculated toward a point 20m along the road from
	// the reference coordinate towards the next LocationReference. if this is
	// the final LocationReference, then omit the bearing.
	//
	// each LocationReference, of which there may be several in this Segment,
	// except for the last must have a bearing calculated from the reference
	// coordinate of this LocationReference.
	Bear *uint32 `protobuf:"varint,2,opt,name=bear" json:"bear,omitempty"`
	// road class at the reference coordinate.
	StartFrc *Segment_RoadClass `protobuf:"varint,3,opt,name=start_frc,json=startFrc,enum=opentraffic.osmlr.Segment_RoadClass" json:"start_frc,omitempty"`
	// form of way at the reference coordinate.
	StartFow *Segment_FormOfWay `protobuf:"varint,4,opt,name=start_fow,json=startFow,enum=opentraffic.osmlr.Segment_FormOfWay" json:"start_fow,omitempty"`
	// lowest road class (most important road) between the start coordinate
	// and the next LocationReference.
	LeastFrc *Segment_RoadClass `protobuf:"varint,5,opt,name=least_frc,json=leastFrc,enum=opentraffic.osmlr.Segment_RoadClass" json:"least_frc,omitempty"`
	// length in meters, rounded to the nearest meter. the maximum allowed
	// length is 15km, but most segments will be much shorter, so a varint
	// representation makes sense.
	//
	// if the length between successive LocationReferences is more than 15km
	// then you MUST insert an intermediate LocationReference.
	Length *uint32 `protobuf:"varint,6,opt,name=length" json:"length,omitempty"`
	// Is this LRP at a node/intersection (true) or along a road (false)?
	// This hint can be useful wen associating OSMLR to routing graphs
	AtNode           *bool  `protobuf:"varint,7,opt,name=at_node,json=atNode" json:"at_node,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Segment_LocationReference) Reset()         { *m = Segment_LocationReference{} }
func (m *Segment_LocationReference) String() string { return proto.CompactTextString(m) }
func (*Segment_LocationReference) ProtoMessage()    {}
func (*Segment_LocationReference) Descriptor() ([]byte, []int) {
	return fileDescriptorSegment, []int{0, 1}
}

func (m *Segment_LocationReference) GetCoord() *Segment_LatLng {
	if m != nil {
		return m.Coord
	}
	return nil
}

func (m *Segment_LocationReference) GetBear() uint32 {
	if m != nil && m.Bear != nil {
		return *m.Bear
	}
	return 0
}

func (m *Segment_LocationReference) GetStartFrc() Segment_RoadClass {
	if m != nil && m.StartFrc != nil {
		return *m.StartFrc
	}
	return Segment_ClassMotorway
}

func (m *Segment_LocationReference) GetStartFow() Segment_FormOfWay {
	if m != nil && m.StartFow != nil {
		return *m.StartFow
	}
	return Segment_FowUndefined
}

func (m *Segment_LocationReference) GetLeastFrc() Segment_RoadClass {
	if m != nil && m.LeastFrc != nil {
		return *m.LeastFrc
	}
	return Segment_ClassMotorway
}

func (m *Segment_LocationReference) GetLength() uint32 {
	if m != nil && m.Length != nil {
		return *m.Length
	}
	return 0
}

func (m *Segment_LocationReference) GetAtNode() bool {
	if m != nil && m.AtNode != nil {
		return *m.AtNode
	}
	return false
}

func init() {
	proto.RegisterType((*Segment)(nil), "opentraffic.osmlr.Segment")
	proto.RegisterType((*Segment_LatLng)(nil), "opentraffic.osmlr.Segment.LatLng")
	proto.RegisterType((*Segment_LocationReference)(nil), "opentraffic.osmlr.Segment.LocationReference")
	proto.RegisterEnum("opentraffic.osmlr.Segment_RoadClass", Segment_RoadClass_name, Segment_RoadClass_value)
	proto.RegisterEnum("opentraffic.osmlr.Segment_FormOfWay", Segment_FormOfWay_name, Segment_FormOfWay_value)
}

func init() { proto.RegisterFile("segment.proto", fileDescriptorSegment) }

var fileDescriptorSegment = []byte{
	// 529 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x93, 0xcb, 0x6e, 0xdb, 0x3c,
	0x10, 0x85, 0x23, 0x5f, 0xe4, 0x64, 0x72, 0xa3, 0x89, 0xfc, 0xf9, 0x85, 0xac, 0xdc, 0xa0, 0x0b,
	0x2f, 0x12, 0x1b, 0xc8, 0xa6, 0xdb, 0xb6, 0x01, 0xb4, 0x4a, 0x9b, 0x42, 0x4a, 0x50, 0xa0, 0x9b,
	0x80, 0x16, 0x47, 0x32, 0x51, 0x9a, 0xa3, 0x52, 0x54, 0x04, 0x3f, 0x53, 0xbb, 0xeb, 0xdb, 0xf4,
	0x69, 0x0a, 0xd1, 0xaa, 0xd1, 0x22, 0x40, 0x8a, 0xae, 0x34, 0x3c, 0x3c, 0x73, 0xe6, 0x23, 0x05,
	0xc2, 0x61, 0x85, 0xc5, 0x0a, 0x8d, 0x9b, 0x95, 0x96, 0x1c, 0xf1, 0x31, 0x95, 0x68, 0x9c, 0x15,
	0x79, 0xae, 0xb2, 0x19, 0x55, 0x2b, 0x6d, 0xcf, 0xbf, 0x87, 0x30, 0x4a, 0x37, 0x26, 0xfe, 0x1a,
	0x06, 0xda, 0x96, 0x55, 0x14, 0x4c, 0xfa, 0xd3, 0xfd, 0xab, 0x8b, 0xd9, 0x13, 0xf7, 0xac, 0x73,
	0xce, 0x6e, 0x28, 0x13, 0x4e, 0x91, 0x49, 0x30, 0x47, 0x8b, 0x26, 0xc3, 0xc4, 0x77, 0x9e, 0x5d,
	0x40, 0x78, 0x23, 0xdc, 0x8d, 0x29, 0x38, 0x83, 0xbe, 0x16, 0x2e, 0x0a, 0x26, 0xc1, 0xf4, 0x38,
	0x69, 0x4b, 0xaf, 0x98, 0x22, 0xea, 0x75, 0x8a, 0x29, 0xce, 0x7e, 0xf4, 0x60, 0xfc, 0x24, 0x89,
	0xbf, 0x82, 0x61, 0x46, 0x64, 0xa5, 0xef, 0xdd, 0xbf, 0x7a, 0xf1, 0x1c, 0x86, 0x9f, 0x95, 0x6c,
	0xfc, 0x9c, 0xc3, 0x60, 0x81, 0xc2, 0xfa, 0x09, 0x87, 0x89, 0xaf, 0xf9, 0x1b, 0xd8, 0xab, 0x9c,
	0xb0, 0xee, 0x21, 0xb7, 0x59, 0xd4, 0x9f, 0x04, 0xd3, 0xa3, 0xab, 0x97, 0xcf, 0x04, 0x26, 0x24,
	0xe4, 0xb5, 0x16, 0x55, 0x95, 0xec, 0xfa, 0xb6, 0xd8, 0x66, 0xbf, 0x45, 0x50, 0x13, 0x0d, 0xfe,
	0x1a, 0x11, 0x93, 0x5d, 0xdd, 0xe6, 0x1f, 0xc5, 0xfa, 0x57, 0x04, 0x35, 0x6d, 0x84, 0x46, 0x51,
	0x6d, 0x28, 0x86, 0xff, 0x42, 0xe1, 0xdb, 0x5a, 0x8a, 0x53, 0x08, 0x35, 0x9a, 0xc2, 0x2d, 0xa3,
	0xd0, 0x1f, 0xaf, 0x5b, 0xf1, 0xff, 0x61, 0x24, 0xdc, 0x83, 0x21, 0x89, 0xd1, 0x68, 0x12, 0x4c,
	0x77, 0x93, 0x50, 0xb8, 0xf7, 0x24, 0xf1, 0xfc, 0x6b, 0x00, 0x7b, 0xdb, 0x20, 0x3e, 0x86, 0x43,
	0x5f, 0xbc, 0x23, 0x47, 0xb6, 0x11, 0x6b, 0xb6, 0xc3, 0x8f, 0x00, 0xbc, 0x74, 0x67, 0x6b, 0xf3,
	0x99, 0x05, 0x9c, 0xc1, 0x81, 0x5f, 0x7f, 0xb0, 0x6a, 0x25, 0xec, 0x9a, 0xf5, 0x38, 0x87, 0x23,
	0xaf, 0xa4, 0x98, 0x91, 0x91, 0xad, 0xd6, 0xdf, 0x06, 0xdd, 0xa1, 0x75, 0xaa, 0x95, 0x06, 0xfc,
	0x3f, 0x18, 0x7b, 0xe9, 0xde, 0x64, 0xed, 0x47, 0xe5, 0x0a, 0x25, 0x1b, 0xf2, 0x13, 0x60, 0x9b,
	0x43, 0x60, 0xa5, 0x24, 0x1a, 0xa7, 0x84, 0x66, 0xe1, 0xd6, 0x9c, 0xa2, 0x7d, 0x54, 0x19, 0xde,
	0xba, 0x25, 0x5a, 0x36, 0x3a, 0xff, 0x16, 0xc0, 0xde, 0xf6, 0xe6, 0x5a, 0x94, 0x98, 0x9a, 0x7b,
	0x23, 0x31, 0x57, 0x06, 0x25, 0xdb, 0xe1, 0xc7, 0xb0, 0x1f, 0x53, 0xb3, 0xa5, 0x0f, 0xf8, 0x19,
	0x9c, 0xb6, 0x42, 0xad, 0x9d, 0x2a, 0x35, 0x5e, 0x0b, 0x6b, 0x95, 0x28, 0xb0, 0xdd, 0xeb, 0xf1,
	0x08, 0x4e, 0x62, 0x6a, 0x52, 0x65, 0x8a, 0x3f, 0x77, 0x3c, 0x7d, 0x4c, 0x4d, 0x42, 0xb5, 0x91,
	0x62, 0x41, 0xb5, 0x63, 0x83, 0x16, 0x33, 0xa6, 0xe6, 0x6e, 0xf3, 0x23, 0xd2, 0x2f, 0xb5, 0xb0,
	0xc8, 0x86, 0xdd, 0xbc, 0x54, 0xab, 0xb2, 0xbd, 0x43, 0x16, 0xf2, 0x03, 0xd8, 0x8d, 0xa9, 0xe9,
	0x70, 0xdf, 0xce, 0x3f, 0x5d, 0x16, 0xca, 0x2d, 0xeb, 0xc5, 0x2c, 0xa3, 0xd5, 0xbc, 0x36, 0xca,
	0xa1, 0xbc, 0x94, 0x56, 0x3d, 0xa2, 0xad, 0xe6, 0x8f, 0x42, 0x2f, 0x85, 0xd6, 0x62, 0x5e, 0x2e,
	0xe6, 0xdd, 0xfb, 0xfb, 0x19, 0x00, 0x00, 0xff, 0xff, 0xc2, 0x6f, 0x68, 0x18, 0x89, 0x03, 0x00,
	0x00,
}
