// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tripcommon.proto

/*
Package valhalla_odin is a generated protocol buffer package.

It is generated from these files:
	tripcommon.proto

It has these top-level messages:
	LatLng
	BoundingBox
	Location
	TransitEgressInfo
	TransitStationInfo
	TransitPlatformInfo
*/
package valhalla_odin

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Location_Type int32

const (
	Location_kBreak   Location_Type = 0
	Location_kThrough Location_Type = 1
)

var Location_Type_name = map[int32]string{
	0: "kBreak",
	1: "kThrough",
}
var Location_Type_value = map[string]int32{
	"kBreak":   0,
	"kThrough": 1,
}

func (x Location_Type) Enum() *Location_Type {
	p := new(Location_Type)
	*p = x
	return p
}
func (x Location_Type) String() string {
	return proto.EnumName(Location_Type_name, int32(x))
}
func (x *Location_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Location_Type_value, data, "Location_Type")
	if err != nil {
		return err
	}
	*x = Location_Type(value)
	return nil
}
func (Location_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorTripcommon, []int{2, 0} }

type Location_SideOfStreet int32

const (
	Location_kNone  Location_SideOfStreet = 0
	Location_kLeft  Location_SideOfStreet = 1
	Location_kRight Location_SideOfStreet = 2
)

var Location_SideOfStreet_name = map[int32]string{
	0: "kNone",
	1: "kLeft",
	2: "kRight",
}
var Location_SideOfStreet_value = map[string]int32{
	"kNone":  0,
	"kLeft":  1,
	"kRight": 2,
}

func (x Location_SideOfStreet) Enum() *Location_SideOfStreet {
	p := new(Location_SideOfStreet)
	*p = x
	return p
}
func (x Location_SideOfStreet) String() string {
	return proto.EnumName(Location_SideOfStreet_name, int32(x))
}
func (x *Location_SideOfStreet) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Location_SideOfStreet_value, data, "Location_SideOfStreet")
	if err != nil {
		return err
	}
	*x = Location_SideOfStreet(value)
	return nil
}
func (Location_SideOfStreet) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTripcommon, []int{2, 1}
}

type TransitPlatformInfo_Type int32

const (
	TransitPlatformInfo_kStop    TransitPlatformInfo_Type = 0
	TransitPlatformInfo_kStation TransitPlatformInfo_Type = 1
)

var TransitPlatformInfo_Type_name = map[int32]string{
	0: "kStop",
	1: "kStation",
}
var TransitPlatformInfo_Type_value = map[string]int32{
	"kStop":    0,
	"kStation": 1,
}

func (x TransitPlatformInfo_Type) Enum() *TransitPlatformInfo_Type {
	p := new(TransitPlatformInfo_Type)
	*p = x
	return p
}
func (x TransitPlatformInfo_Type) String() string {
	return proto.EnumName(TransitPlatformInfo_Type_name, int32(x))
}
func (x *TransitPlatformInfo_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TransitPlatformInfo_Type_value, data, "TransitPlatformInfo_Type")
	if err != nil {
		return err
	}
	*x = TransitPlatformInfo_Type(value)
	return nil
}
func (TransitPlatformInfo_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTripcommon, []int{5, 0}
}

type LatLng struct {
	Lat              *float32 `protobuf:"fixed32,1,opt,name=lat" json:"lat,omitempty"`
	Lng              *float32 `protobuf:"fixed32,2,opt,name=lng" json:"lng,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *LatLng) Reset()                    { *m = LatLng{} }
func (m *LatLng) String() string            { return proto.CompactTextString(m) }
func (*LatLng) ProtoMessage()               {}
func (*LatLng) Descriptor() ([]byte, []int) { return fileDescriptorTripcommon, []int{0} }

func (m *LatLng) GetLat() float32 {
	if m != nil && m.Lat != nil {
		return *m.Lat
	}
	return 0
}

func (m *LatLng) GetLng() float32 {
	if m != nil && m.Lng != nil {
		return *m.Lng
	}
	return 0
}

type BoundingBox struct {
	MinLl            *LatLng `protobuf:"bytes,1,opt,name=min_ll,json=minLl" json:"min_ll,omitempty"`
	MaxLl            *LatLng `protobuf:"bytes,2,opt,name=max_ll,json=maxLl" json:"max_ll,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *BoundingBox) Reset()                    { *m = BoundingBox{} }
func (m *BoundingBox) String() string            { return proto.CompactTextString(m) }
func (*BoundingBox) ProtoMessage()               {}
func (*BoundingBox) Descriptor() ([]byte, []int) { return fileDescriptorTripcommon, []int{1} }

func (m *BoundingBox) GetMinLl() *LatLng {
	if m != nil {
		return m.MinLl
	}
	return nil
}

func (m *BoundingBox) GetMaxLl() *LatLng {
	if m != nil {
		return m.MaxLl
	}
	return nil
}

type Location struct {
	Ll                  *LatLng                `protobuf:"bytes,1,opt,name=ll" json:"ll,omitempty"`
	Type                *Location_Type         `protobuf:"varint,2,opt,name=type,enum=valhalla.odin.Location_Type,def=0" json:"type,omitempty"`
	Heading             *uint32                `protobuf:"varint,3,opt,name=heading" json:"heading,omitempty"`
	Name                *string                `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	Street              *string                `protobuf:"bytes,5,opt,name=street" json:"street,omitempty"`
	City                *string                `protobuf:"bytes,6,opt,name=city" json:"city,omitempty"`
	State               *string                `protobuf:"bytes,7,opt,name=state" json:"state,omitempty"`
	PostalCode          *string                `protobuf:"bytes,8,opt,name=postal_code,json=postalCode" json:"postal_code,omitempty"`
	Country             *string                `protobuf:"bytes,9,opt,name=country" json:"country,omitempty"`
	Phone               *string                `protobuf:"bytes,10,opt,name=phone" json:"phone,omitempty"`
	Url                 *string                `protobuf:"bytes,11,opt,name=url" json:"url,omitempty"`
	DateTime            *string                `protobuf:"bytes,12,opt,name=date_time,json=dateTime" json:"date_time,omitempty"`
	SideOfStreet        *Location_SideOfStreet `protobuf:"varint,13,opt,name=side_of_street,json=sideOfStreet,enum=valhalla.odin.Location_SideOfStreet" json:"side_of_street,omitempty"`
	HeadingTolerance    *uint32                `protobuf:"varint,14,opt,name=heading_tolerance,json=headingTolerance,def=60" json:"heading_tolerance,omitempty"`
	NodeSnapTolerance   *uint32                `protobuf:"varint,15,opt,name=node_snap_tolerance,json=nodeSnapTolerance,def=5" json:"node_snap_tolerance,omitempty"`
	WayId               *uint64                `protobuf:"varint,16,opt,name=way_id,json=wayId" json:"way_id,omitempty"`
	MinimumReachability *uint32                `protobuf:"varint,17,opt,name=minimum_reachability,json=minimumReachability,def=0" json:"minimum_reachability,omitempty"`
	Radius              *uint32                `protobuf:"varint,18,opt,name=radius,def=0" json:"radius,omitempty"`
	Accuracy            *uint32                `protobuf:"varint,19,opt,name=accuracy" json:"accuracy,omitempty"`
	Time                *float64               `protobuf:"fixed64,20,opt,name=time,def=-1" json:"time,omitempty"`
	RankCandidates      *bool                  `protobuf:"varint,21,opt,name=rank_candidates,json=rankCandidates,def=1" json:"rank_candidates,omitempty"`
	// outputs
	PathEdges        []*Location_PathEdge `protobuf:"bytes,22,rep,name=path_edges,json=pathEdges" json:"path_edges,omitempty"`
	FilteredEdges    []*Location_PathEdge `protobuf:"bytes,23,rep,name=filtered_edges,json=filteredEdges" json:"filtered_edges,omitempty"`
	OriginalIndex    *uint32              `protobuf:"varint,24,opt,name=original_index,json=originalIndex" json:"original_index,omitempty"`
	ProjectedLl      *LatLng              `protobuf:"bytes,25,opt,name=projected_ll,json=projectedLl" json:"projected_ll,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *Location) Reset()                    { *m = Location{} }
func (m *Location) String() string            { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()               {}
func (*Location) Descriptor() ([]byte, []int) { return fileDescriptorTripcommon, []int{2} }

const Default_Location_Type Location_Type = Location_kBreak
const Default_Location_HeadingTolerance uint32 = 60
const Default_Location_NodeSnapTolerance uint32 = 5
const Default_Location_MinimumReachability uint32 = 0
const Default_Location_Radius uint32 = 0
const Default_Location_Time float64 = -1
const Default_Location_RankCandidates bool = true

func (m *Location) GetLl() *LatLng {
	if m != nil {
		return m.Ll
	}
	return nil
}

func (m *Location) GetType() Location_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_Location_Type
}

func (m *Location) GetHeading() uint32 {
	if m != nil && m.Heading != nil {
		return *m.Heading
	}
	return 0
}

func (m *Location) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Location) GetStreet() string {
	if m != nil && m.Street != nil {
		return *m.Street
	}
	return ""
}

func (m *Location) GetCity() string {
	if m != nil && m.City != nil {
		return *m.City
	}
	return ""
}

func (m *Location) GetState() string {
	if m != nil && m.State != nil {
		return *m.State
	}
	return ""
}

func (m *Location) GetPostalCode() string {
	if m != nil && m.PostalCode != nil {
		return *m.PostalCode
	}
	return ""
}

func (m *Location) GetCountry() string {
	if m != nil && m.Country != nil {
		return *m.Country
	}
	return ""
}

func (m *Location) GetPhone() string {
	if m != nil && m.Phone != nil {
		return *m.Phone
	}
	return ""
}

func (m *Location) GetUrl() string {
	if m != nil && m.Url != nil {
		return *m.Url
	}
	return ""
}

func (m *Location) GetDateTime() string {
	if m != nil && m.DateTime != nil {
		return *m.DateTime
	}
	return ""
}

func (m *Location) GetSideOfStreet() Location_SideOfStreet {
	if m != nil && m.SideOfStreet != nil {
		return *m.SideOfStreet
	}
	return Location_kNone
}

func (m *Location) GetHeadingTolerance() uint32 {
	if m != nil && m.HeadingTolerance != nil {
		return *m.HeadingTolerance
	}
	return Default_Location_HeadingTolerance
}

func (m *Location) GetNodeSnapTolerance() uint32 {
	if m != nil && m.NodeSnapTolerance != nil {
		return *m.NodeSnapTolerance
	}
	return Default_Location_NodeSnapTolerance
}

func (m *Location) GetWayId() uint64 {
	if m != nil && m.WayId != nil {
		return *m.WayId
	}
	return 0
}

func (m *Location) GetMinimumReachability() uint32 {
	if m != nil && m.MinimumReachability != nil {
		return *m.MinimumReachability
	}
	return Default_Location_MinimumReachability
}

func (m *Location) GetRadius() uint32 {
	if m != nil && m.Radius != nil {
		return *m.Radius
	}
	return Default_Location_Radius
}

func (m *Location) GetAccuracy() uint32 {
	if m != nil && m.Accuracy != nil {
		return *m.Accuracy
	}
	return 0
}

func (m *Location) GetTime() float64 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return Default_Location_Time
}

func (m *Location) GetRankCandidates() bool {
	if m != nil && m.RankCandidates != nil {
		return *m.RankCandidates
	}
	return Default_Location_RankCandidates
}

func (m *Location) GetPathEdges() []*Location_PathEdge {
	if m != nil {
		return m.PathEdges
	}
	return nil
}

func (m *Location) GetFilteredEdges() []*Location_PathEdge {
	if m != nil {
		return m.FilteredEdges
	}
	return nil
}

func (m *Location) GetOriginalIndex() uint32 {
	if m != nil && m.OriginalIndex != nil {
		return *m.OriginalIndex
	}
	return 0
}

func (m *Location) GetProjectedLl() *LatLng {
	if m != nil {
		return m.ProjectedLl
	}
	return nil
}

type Location_PathEdge struct {
	GraphId             *uint64                `protobuf:"varint,1,opt,name=graph_id,json=graphId" json:"graph_id,omitempty"`
	PercentAlong        *float32               `protobuf:"fixed32,2,opt,name=percent_along,json=percentAlong" json:"percent_along,omitempty"`
	Ll                  *LatLng                `protobuf:"bytes,3,opt,name=ll" json:"ll,omitempty"`
	SideOfStreet        *Location_SideOfStreet `protobuf:"varint,4,opt,name=side_of_street,json=sideOfStreet,enum=valhalla.odin.Location_SideOfStreet" json:"side_of_street,omitempty"`
	Distance            *float32               `protobuf:"fixed32,5,opt,name=distance" json:"distance,omitempty"`
	MinimumReachability *int32                 `protobuf:"varint,6,opt,name=minimum_reachability,json=minimumReachability" json:"minimum_reachability,omitempty"`
	BeginNode           *bool                  `protobuf:"varint,7,opt,name=begin_node,json=beginNode" json:"begin_node,omitempty"`
	EndNode             *bool                  `protobuf:"varint,8,opt,name=end_node,json=endNode" json:"end_node,omitempty"`
	Names               []string               `protobuf:"bytes,10,rep,name=names" json:"names,omitempty"`
	XXX_unrecognized    []byte                 `json:"-"`
}

func (m *Location_PathEdge) Reset()                    { *m = Location_PathEdge{} }
func (m *Location_PathEdge) String() string            { return proto.CompactTextString(m) }
func (*Location_PathEdge) ProtoMessage()               {}
func (*Location_PathEdge) Descriptor() ([]byte, []int) { return fileDescriptorTripcommon, []int{2, 0} }

func (m *Location_PathEdge) GetGraphId() uint64 {
	if m != nil && m.GraphId != nil {
		return *m.GraphId
	}
	return 0
}

func (m *Location_PathEdge) GetPercentAlong() float32 {
	if m != nil && m.PercentAlong != nil {
		return *m.PercentAlong
	}
	return 0
}

func (m *Location_PathEdge) GetLl() *LatLng {
	if m != nil {
		return m.Ll
	}
	return nil
}

func (m *Location_PathEdge) GetSideOfStreet() Location_SideOfStreet {
	if m != nil && m.SideOfStreet != nil {
		return *m.SideOfStreet
	}
	return Location_kNone
}

func (m *Location_PathEdge) GetDistance() float32 {
	if m != nil && m.Distance != nil {
		return *m.Distance
	}
	return 0
}

func (m *Location_PathEdge) GetMinimumReachability() int32 {
	if m != nil && m.MinimumReachability != nil {
		return *m.MinimumReachability
	}
	return 0
}

func (m *Location_PathEdge) GetBeginNode() bool {
	if m != nil && m.BeginNode != nil {
		return *m.BeginNode
	}
	return false
}

func (m *Location_PathEdge) GetEndNode() bool {
	if m != nil && m.EndNode != nil {
		return *m.EndNode
	}
	return false
}

func (m *Location_PathEdge) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

type TransitEgressInfo struct {
	OnestopId        *string `protobuf:"bytes,1,opt,name=onestop_id,json=onestopId" json:"onestop_id,omitempty"`
	Name             *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Ll               *LatLng `protobuf:"bytes,3,opt,name=ll" json:"ll,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TransitEgressInfo) Reset()                    { *m = TransitEgressInfo{} }
func (m *TransitEgressInfo) String() string            { return proto.CompactTextString(m) }
func (*TransitEgressInfo) ProtoMessage()               {}
func (*TransitEgressInfo) Descriptor() ([]byte, []int) { return fileDescriptorTripcommon, []int{3} }

func (m *TransitEgressInfo) GetOnestopId() string {
	if m != nil && m.OnestopId != nil {
		return *m.OnestopId
	}
	return ""
}

func (m *TransitEgressInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *TransitEgressInfo) GetLl() *LatLng {
	if m != nil {
		return m.Ll
	}
	return nil
}

type TransitStationInfo struct {
	OnestopId        *string `protobuf:"bytes,1,opt,name=onestop_id,json=onestopId" json:"onestop_id,omitempty"`
	Name             *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Ll               *LatLng `protobuf:"bytes,3,opt,name=ll" json:"ll,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TransitStationInfo) Reset()                    { *m = TransitStationInfo{} }
func (m *TransitStationInfo) String() string            { return proto.CompactTextString(m) }
func (*TransitStationInfo) ProtoMessage()               {}
func (*TransitStationInfo) Descriptor() ([]byte, []int) { return fileDescriptorTripcommon, []int{4} }

func (m *TransitStationInfo) GetOnestopId() string {
	if m != nil && m.OnestopId != nil {
		return *m.OnestopId
	}
	return ""
}

func (m *TransitStationInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *TransitStationInfo) GetLl() *LatLng {
	if m != nil {
		return m.Ll
	}
	return nil
}

type TransitPlatformInfo struct {
	Type              *TransitPlatformInfo_Type `protobuf:"varint,1,opt,name=type,enum=valhalla.odin.TransitPlatformInfo_Type" json:"type,omitempty"`
	OnestopId         *string                   `protobuf:"bytes,2,opt,name=onestop_id,json=onestopId" json:"onestop_id,omitempty"`
	Name              *string                   `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	ArrivalDateTime   *string                   `protobuf:"bytes,4,opt,name=arrival_date_time,json=arrivalDateTime" json:"arrival_date_time,omitempty"`
	DepartureDateTime *string                   `protobuf:"bytes,5,opt,name=departure_date_time,json=departureDateTime" json:"departure_date_time,omitempty"`
	AssumedSchedule   *bool                     `protobuf:"varint,6,opt,name=assumed_schedule,json=assumedSchedule" json:"assumed_schedule,omitempty"`
	Ll                *LatLng                   `protobuf:"bytes,7,opt,name=ll" json:"ll,omitempty"`
	StationOnestopId  *string                   `protobuf:"bytes,8,opt,name=station_onestop_id,json=stationOnestopId" json:"station_onestop_id,omitempty"`
	StationName       *string                   `protobuf:"bytes,9,opt,name=station_name,json=stationName" json:"station_name,omitempty"`
	XXX_unrecognized  []byte                    `json:"-"`
}

func (m *TransitPlatformInfo) Reset()                    { *m = TransitPlatformInfo{} }
func (m *TransitPlatformInfo) String() string            { return proto.CompactTextString(m) }
func (*TransitPlatformInfo) ProtoMessage()               {}
func (*TransitPlatformInfo) Descriptor() ([]byte, []int) { return fileDescriptorTripcommon, []int{5} }

func (m *TransitPlatformInfo) GetType() TransitPlatformInfo_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return TransitPlatformInfo_kStop
}

func (m *TransitPlatformInfo) GetOnestopId() string {
	if m != nil && m.OnestopId != nil {
		return *m.OnestopId
	}
	return ""
}

func (m *TransitPlatformInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *TransitPlatformInfo) GetArrivalDateTime() string {
	if m != nil && m.ArrivalDateTime != nil {
		return *m.ArrivalDateTime
	}
	return ""
}

func (m *TransitPlatformInfo) GetDepartureDateTime() string {
	if m != nil && m.DepartureDateTime != nil {
		return *m.DepartureDateTime
	}
	return ""
}

func (m *TransitPlatformInfo) GetAssumedSchedule() bool {
	if m != nil && m.AssumedSchedule != nil {
		return *m.AssumedSchedule
	}
	return false
}

func (m *TransitPlatformInfo) GetLl() *LatLng {
	if m != nil {
		return m.Ll
	}
	return nil
}

func (m *TransitPlatformInfo) GetStationOnestopId() string {
	if m != nil && m.StationOnestopId != nil {
		return *m.StationOnestopId
	}
	return ""
}

func (m *TransitPlatformInfo) GetStationName() string {
	if m != nil && m.StationName != nil {
		return *m.StationName
	}
	return ""
}

func init() {
	proto.RegisterType((*LatLng)(nil), "valhalla.odin.LatLng")
	proto.RegisterType((*BoundingBox)(nil), "valhalla.odin.BoundingBox")
	proto.RegisterType((*Location)(nil), "valhalla.odin.Location")
	proto.RegisterType((*Location_PathEdge)(nil), "valhalla.odin.Location.PathEdge")
	proto.RegisterType((*TransitEgressInfo)(nil), "valhalla.odin.TransitEgressInfo")
	proto.RegisterType((*TransitStationInfo)(nil), "valhalla.odin.TransitStationInfo")
	proto.RegisterType((*TransitPlatformInfo)(nil), "valhalla.odin.TransitPlatformInfo")
	proto.RegisterEnum("valhalla.odin.Location_Type", Location_Type_name, Location_Type_value)
	proto.RegisterEnum("valhalla.odin.Location_SideOfStreet", Location_SideOfStreet_name, Location_SideOfStreet_value)
	proto.RegisterEnum("valhalla.odin.TransitPlatformInfo_Type", TransitPlatformInfo_Type_name, TransitPlatformInfo_Type_value)
}

func init() { proto.RegisterFile("tripcommon.proto", fileDescriptorTripcommon) }

var fileDescriptorTripcommon = []byte{
	// 1005 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0x6d, 0x6f, 0xdb, 0x36,
	0x10, 0xae, 0xfc, 0x16, 0xf9, 0xfc, 0x12, 0x99, 0x49, 0x3b, 0x26, 0xdb, 0x50, 0xcf, 0x5b, 0x31,
	0x6f, 0x48, 0xbd, 0x24, 0xd8, 0x86, 0x22, 0xfb, 0x30, 0x2c, 0x5d, 0x31, 0x64, 0x30, 0xd2, 0x42,
	0xce, 0x77, 0x81, 0x15, 0x69, 0x89, 0x8b, 0x44, 0x0a, 0x14, 0xd5, 0xc6, 0x3f, 0x68, 0xff, 0x6a,
	0x3f, 0x63, 0x3f, 0x60, 0x20, 0x45, 0xbb, 0x6e, 0xd7, 0x34, 0xc5, 0x80, 0x7d, 0xe3, 0x3d, 0xcf,
	0xdd, 0x91, 0xf7, 0xc2, 0x3b, 0x08, 0xb4, 0xe2, 0x45, 0x2c, 0xf3, 0x5c, 0x8a, 0x59, 0xa1, 0xa4,
	0x96, 0x68, 0xf0, 0x8a, 0x64, 0x29, 0xc9, 0x32, 0x32, 0x93, 0x94, 0x8b, 0xc9, 0x11, 0x74, 0xe6,
	0x44, 0xcf, 0x45, 0x82, 0x02, 0x68, 0x66, 0x44, 0x63, 0x6f, 0xec, 0x4d, 0x1b, 0xa1, 0x39, 0x5a,
	0x44, 0x24, 0xb8, 0xe1, 0x10, 0x91, 0x4c, 0x38, 0xf4, 0xce, 0x65, 0x25, 0x28, 0x17, 0xc9, 0xb9,
	0xbc, 0x41, 0x47, 0xd0, 0xc9, 0xb9, 0x88, 0xb2, 0xcc, 0x5a, 0xf5, 0x4e, 0xef, 0xcf, 0xde, 0x72,
	0x3e, 0xab, 0x3d, 0x87, 0xed, 0x9c, 0x8b, 0x79, 0x66, 0xb5, 0xc9, 0x8d, 0xd1, 0x6e, 0x7c, 0x58,
	0x9b, 0xdc, 0xcc, 0xb3, 0xc9, 0xdf, 0x00, 0xfe, 0x5c, 0xc6, 0x44, 0x73, 0x29, 0xd0, 0x23, 0x68,
	0xdc, 0x75, 0x49, 0x23, 0xcb, 0xd0, 0x13, 0x68, 0xe9, 0x55, 0xc1, 0xac, 0xff, 0xe1, 0xe9, 0x67,
	0xef, 0x2a, 0x3a, 0x6f, 0xb3, 0xab, 0x55, 0xc1, 0xce, 0x3a, 0xd7, 0xe7, 0x8a, 0x91, 0xeb, 0xd0,
	0x5a, 0x20, 0x0c, 0x3b, 0x29, 0x23, 0x26, 0x2e, 0xdc, 0x1c, 0x7b, 0xd3, 0x41, 0xb8, 0x16, 0x11,
	0x82, 0x96, 0x20, 0x39, 0xc3, 0xad, 0xb1, 0x37, 0xed, 0x86, 0xf6, 0x8c, 0x1e, 0x40, 0xa7, 0xd4,
	0x8a, 0x31, 0x8d, 0xdb, 0x16, 0x75, 0x92, 0xd1, 0x8d, 0xb9, 0x5e, 0xe1, 0x4e, 0xad, 0x6b, 0xce,
	0x68, 0x1f, 0xda, 0xa5, 0x26, 0x9a, 0xe1, 0x1d, 0x0b, 0xd6, 0x02, 0x7a, 0x08, 0xbd, 0x42, 0x96,
	0x9a, 0x64, 0x51, 0x2c, 0x29, 0xc3, 0xbe, 0xe5, 0xa0, 0x86, 0x9e, 0x4a, 0x6a, 0x1f, 0x14, 0xcb,
	0x4a, 0x68, 0xb5, 0xc2, 0x5d, 0x4b, 0xae, 0x45, 0xe3, 0xb0, 0x48, 0xa5, 0x60, 0x18, 0x6a, 0x87,
	0x56, 0x30, 0xb5, 0xaa, 0x54, 0x86, 0x7b, 0x16, 0x33, 0x47, 0xf4, 0x29, 0x74, 0x29, 0xd1, 0x2c,
	0xd2, 0x3c, 0x67, 0xb8, 0x6f, 0x71, 0xdf, 0x00, 0x57, 0x3c, 0x67, 0xe8, 0x77, 0x18, 0x96, 0x9c,
	0xb2, 0x48, 0x2e, 0x23, 0x17, 0xc9, 0xc0, 0xe6, 0xec, 0xab, 0xdb, 0x72, 0xb6, 0xe0, 0x94, 0x3d,
	0x5f, 0x2e, 0xac, 0x6e, 0xd8, 0x2f, 0xb7, 0x24, 0xf4, 0x1d, 0x8c, 0x5c, 0xb2, 0x22, 0x2d, 0x33,
	0xa6, 0x88, 0x88, 0x19, 0x1e, 0x9a, 0x2c, 0x9e, 0x35, 0x7e, 0x3c, 0x0e, 0x03, 0x47, 0x5e, 0xad,
	0x39, 0x74, 0x02, 0x7b, 0x42, 0x52, 0x16, 0x95, 0x82, 0x14, 0x5b, 0x26, 0xbb, 0xd6, 0xc4, 0xfb,
	0x21, 0x1c, 0x19, 0x76, 0x21, 0x48, 0xf1, 0xc6, 0xe4, 0x3e, 0x74, 0x5e, 0x93, 0x55, 0xc4, 0x29,
	0x0e, 0xc6, 0xde, 0xb4, 0x15, 0xb6, 0x5f, 0x93, 0xd5, 0x05, 0x45, 0xdf, 0xc3, 0x7e, 0xce, 0x05,
	0xcf, 0xab, 0x3c, 0x52, 0x8c, 0xc4, 0x29, 0x79, 0xc9, 0x33, 0x53, 0x80, 0x51, 0xed, 0xea, 0x38,
	0xdc, 0x73, 0x74, 0xb8, 0xc5, 0xa2, 0x03, 0xe8, 0x28, 0x42, 0x79, 0x55, 0x62, 0xb4, 0xd6, 0x73,
	0x00, 0x3a, 0x04, 0x9f, 0xc4, 0x71, 0xa5, 0x48, 0xbc, 0xc2, 0x7b, 0xb6, 0x11, 0x36, 0x32, 0x7a,
	0x00, 0x2d, 0x9b, 0xcb, 0xfd, 0xb1, 0x37, 0xf5, 0xce, 0x1a, 0x8f, 0x4f, 0x42, 0x2b, 0xa3, 0xc7,
	0xb0, 0xab, 0x88, 0xb8, 0x8e, 0x62, 0x22, 0x28, 0x37, 0x19, 0x2e, 0xf1, 0xfd, 0xb1, 0x37, 0xf5,
	0xcf, 0x5a, 0x5a, 0x55, 0x2c, 0x1c, 0x1a, 0xf2, 0xe9, 0x86, 0x43, 0x3f, 0x03, 0x14, 0x44, 0xa7,
	0x11, 0xa3, 0x09, 0x2b, 0xf1, 0x83, 0x71, 0x73, 0xda, 0x3b, 0x1d, 0xdf, 0x96, 0xf6, 0x17, 0x44,
	0xa7, 0xcf, 0x68, 0xc2, 0xc2, 0x6e, 0xe1, 0x4e, 0x25, 0xfa, 0x0d, 0x86, 0x4b, 0x9e, 0x69, 0xa6,
	0x18, 0x75, 0x4e, 0x3e, 0xf9, 0x48, 0x27, 0x83, 0xb5, 0x5d, 0xed, 0xe8, 0x11, 0x0c, 0xa5, 0xe2,
	0x09, 0x17, 0x24, 0x8b, 0xb8, 0xa0, 0xec, 0x06, 0x63, 0x1b, 0xf2, 0x60, 0x8d, 0x5e, 0x18, 0x10,
	0x3d, 0x81, 0x7e, 0xa1, 0xe4, 0x1f, 0x2c, 0xd6, 0x8c, 0x9a, 0xdf, 0x7b, 0xf0, 0xa1, 0x6f, 0xd8,
	0xdb, 0xa8, 0xce, 0xb3, 0xc3, 0xbf, 0x1a, 0xe0, 0xaf, 0x2f, 0x47, 0x07, 0xe0, 0x27, 0x8a, 0x14,
	0xa9, 0x29, 0xa2, 0x67, 0x8b, 0xb8, 0x63, 0xe5, 0x0b, 0x8a, 0xbe, 0x84, 0x41, 0xc1, 0x54, 0xcc,
	0x84, 0x8e, 0x48, 0x26, 0x37, 0x23, 0xa7, 0xef, 0xc0, 0x5f, 0x0c, 0xe6, 0x66, 0x40, 0xf3, 0xae,
	0x19, 0xf0, 0xef, 0xce, 0x6e, 0xfd, 0xe7, 0xce, 0x3e, 0x04, 0x9f, 0xf2, 0x52, 0xdb, 0xee, 0x6c,
	0xdb, 0x27, 0x6d, 0x64, 0x74, 0x72, 0x4b, 0xeb, 0x99, 0xbf, 0xdf, 0x7e, 0x7f, 0xdf, 0x7d, 0x0e,
	0xf0, 0x92, 0x25, 0x5c, 0x44, 0xa6, 0xbf, 0xed, 0x3c, 0xf0, 0xc3, 0xae, 0x45, 0x2e, 0xcd, 0x97,
	0x3f, 0x00, 0x9f, 0x09, 0x5a, 0x93, 0xbe, 0x25, 0x77, 0x98, 0xa0, 0x96, 0xda, 0x87, 0xb6, 0x19,
	0x3c, 0x25, 0x86, 0x71, 0xd3, 0xfc, 0x79, 0x2b, 0x4c, 0xc6, 0xd0, 0x32, 0xa3, 0x0c, 0x01, 0xb8,
	0x61, 0x16, 0xdc, 0x43, 0x7d, 0xf0, 0xaf, 0xaf, 0x52, 0x25, 0xab, 0x24, 0x0d, 0xbc, 0xc9, 0x31,
	0xf4, 0xb7, 0xc3, 0x43, 0x5d, 0x68, 0x5f, 0x5f, 0x4a, 0xc1, 0x82, 0x7b, 0xf6, 0x38, 0x67, 0x4b,
	0x1d, 0x78, 0xd6, 0x3e, 0xe4, 0x49, 0xaa, 0x83, 0xc6, 0x24, 0x87, 0xd1, 0x95, 0x22, 0xa2, 0xe4,
	0xfa, 0x59, 0xa2, 0x58, 0x59, 0x5e, 0x88, 0xa5, 0x34, 0x0f, 0x97, 0x82, 0x95, 0x5a, 0x16, 0xeb,
	0xe2, 0x75, 0xc3, 0xae, 0x43, 0x2e, 0xe8, 0x66, 0x44, 0x36, 0xb6, 0x46, 0xe4, 0xc7, 0x55, 0x6b,
	0x22, 0x00, 0xb9, 0xeb, 0x16, 0xda, 0x96, 0xe3, 0x7f, 0xbe, 0xef, 0xcf, 0x26, 0xec, 0xb9, 0x0b,
	0x5f, 0x64, 0x44, 0x2f, 0xa5, 0xca, 0xed, 0x8d, 0x3f, 0xb9, 0xcd, 0xe1, 0xd9, 0x5e, 0xf9, 0xfa,
	0x1d, 0x07, 0xef, 0xb1, 0xb0, 0x4b, 0xc4, 0x2d, 0x8f, 0xb7, 0x9f, 0xdb, 0xb8, 0xed, 0xb9, 0xcd,
	0xad, 0xe7, 0x7e, 0x0b, 0x23, 0xa2, 0x14, 0x7f, 0x45, 0xb2, 0xe8, 0xcd, 0x90, 0xae, 0x57, 0xcc,
	0xae, 0x23, 0x7e, 0x5d, 0xcf, 0xea, 0x19, 0xec, 0x51, 0x56, 0x10, 0xa5, 0x2b, 0xc5, 0xb6, 0xb4,
	0xeb, 0xd5, 0x33, 0xda, 0x50, 0x1b, 0xfd, 0x6f, 0x20, 0x20, 0x65, 0x59, 0xe5, 0x8c, 0x46, 0x65,
	0x9c, 0x32, 0x5a, 0x65, 0xcc, 0x76, 0xa5, 0x1f, 0xee, 0x3a, 0x7c, 0xe1, 0x60, 0x97, 0xb5, 0x9d,
	0xbb, 0xfe, 0xd4, 0x11, 0xa0, 0xb2, 0x2e, 0x4f, 0xb4, 0x15, 0x68, 0xbd, 0xb4, 0x02, 0xc7, 0x3c,
	0xdf, 0xc4, 0xfb, 0x05, 0xf4, 0xd7, 0xda, 0x36, 0xee, 0x7a, 0x7f, 0xf5, 0x1c, 0x76, 0x49, 0x72,
	0x36, 0x79, 0xe8, 0x3a, 0xd7, 0x34, 0xe1, 0x42, 0xcb, 0xc2, 0x35, 0xae, 0xeb, 0x81, 0xc0, 0xfb,
	0x27, 0x00, 0x00, 0xff, 0xff, 0x09, 0xc6, 0x34, 0x91, 0xb8, 0x08, 0x00, 0x00,
}
